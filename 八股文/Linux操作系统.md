## 



# 一、Linux系统相关

## 1. Linux系统文件格式：7/8种

普通文件：-

目录文件：d 目录

字符设备文件：c 即串行端口的接口设备，例如键盘、鼠标等等

块设备文件：b 就是存储数据以供系统存取的接口设备，简单而言就是硬盘。

软连接：l 是一种特殊文件，指向一个真实存在的文件链接，类似于Windows下的快捷方式，链接文件的不同，又可分为硬链接文件和符号链接文件。

管道文件：p 是一种很特殊的文件，主要用于不同进程的信息传递。

套接字：s 这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。

未知文件。
占磁盘空间：普通文件、目录、软链接
其他的都是伪文件，不占磁盘空间



## 2.文件权限rwx

用户对文件的权限

r—4		w—2		x—1

rwx|r-x|r-x	所有者u、同组用户g、其他o

使用chown 一次修改所有者和所属组：

## 3.Linux软链接、硬链接

#### 软链接

ln -s xiao xiao.s	用相对路径给xiao文件或者目录创建一个软链接xiao.s

软链接相当于快捷方式，有大小，大小为访问路径，相对路径创建的软链接大小为4字节

相对路径创建的软链接不可以像windows快捷方式那样剪贴到别的路径

ln -s ./xiao xiao.soft  绝对路径创建软链接xiao.soft

绝对路径创建的软链接大小为6字节

绝对路径创建的软链接可以像windows快捷方式那样剪贴到别的路径（用什么路径创建的就可以在什么路径中访问，建议用/home/xiaodexin/桌面/main/xiao，这个路径大小为36字节）

ln -s /home/xiaodexin/桌面/main/xiao xiao.soft

注意：为保证软链接可以随意搬移，最好用绝对路径创建软连接

#### 硬链接

ln xiao.txt xiao.h  硬连接不加-s

大小等于源文件大小

对创建的硬链接文件进行修改，与之相链接的文件（包括源文件以及其他硬链接文件）也会发生改变，两者是同步的

大概相当于指针的思想   有相同的Inode



## 4.GCC编译

gcc编译：

	4步骤： 预处理、编译、汇编、连接。
	
	-I：	指定头文件所在目录位置（头文件与源文件不在同一路径下）。
	
	-c：	只做预处理、编译、汇编。得到 二进制 文件！！！（看不懂）
	
	-g：	编译时添加调试语句。 主要支持 gdb 调试。
	
	-Wall： 显示所有警告信息。
	
	-E:		生成预处理文件.i
	
	-D：	向程序中“动态”注册宏定义。   #define NAME VALUE 	（相当于嵌入式中在设置中直接定义宏定义，即编译时注册宏定义）
	-l: 指定动态库名
	-L：指定动态库路径

​	预编译（预处理）：gcc -E hello.c -o hello.i		去掉注释，导入头文件，展开宏定义
​		
​	编译：gcc -S hello.i -o hello.s								高级语言代码变为汇编代码
​	
​	汇编：gcc -c hello.s -o hello.o								汇编代码变为目标代码（二进制010101）
​	
​	链接：gcc hello.o -o hello.out								目标代码变为可执行文件

![image-20220102205047533](/C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220102205047533.png)



​      





# 二.进程

### 1.进程三种状态

(其实是5种)

运行态：进程占用cpu，正在cpu上运行

就绪态：已经具备运行条件，但由于没有空闲cpu，而暂时不能运行

阻塞态：因等待某一事件而暂时不能运行

除此之外还有创建态和终止态

创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB

终止态：进程正在从系统中撤销，操作系统回收进程拥有的资源



### <u>2.进程间通信方式</u>

进程通信是指进程之间的信息交换，进程的通信方式有：

(1)管道，管道是连接读写进程的一个共享文件，实质就是内存中开辟的一个缓冲区，管道只能半双工通信分为有名管道和无名管道

无名管道只能用在有亲缘关系的进程间,比如父子进程(因为要共享文件描述符)。有名管道允许无亲缘关系的进程间进行通信(通过文件路径)。一个进程创建了一个管道,并调用fork创建自己的一个子进程后,父进程关闭读管道端,子进程关闭写管道端,这样就提供了两个进程之间数据流动的一种方式。

无名管道：优点：简单方便；缺点：1）局限于单向通信2）只能创建在它的进程以及其有亲缘关系的进程之间;3）缓冲区有限；
有名管道：优点：可以实现任意关系的进程间的通信；缺点：1）它会长期存于系统中，使用不当容易出错；2）缓冲区有限

(2)信号量
信号量可以看作是一个整型计数器，可以表示资源的数量，主要是用来实现进程间的互斥和同步。

控制信号量的方式有两种原子操作，一个是P操作，这个操作会把信号量减1，如果相减后信号量<0，则表明资源被占用，进程需阻塞等待；相减后信号量>=0，则表明还有资源可用，进程可正常继续执行。另一个是V操作，这个操作会把信号量加1，相加后信号量<=0,表明当前有阻塞中的进程，于是唤醒该进程，相加后信号量>0,表示当期没有阻塞中的进程。

优点：可以同步进程；缺点：信号量有限

(2)消息队列

消息队列是消息的链表,存放在内核中并由消息队列标识符标识.Linux允许不同进程将格式化的数据流以消息队列形式发送给任意进程。消息队列克服了信号传递信息少,管道只能承载无格式字节流和缓冲区大小受限的问题.
优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收的同步，不用考虑同步问题，方便；缺点：存在用户态与内核态之间的数据拷贝开销。

(4)共享内存：(不经过内核，它是最快的方式)

共享内存就是拿出一块虚拟地址空间，映射到能被其他进程所访问的物理内存中,这段共享内存由一个进程创建,多个进程都可以访问，节省了很多拷贝操作，提高了进程间通信的速度.

共享内存是最快的IPC(进程间通信)方式.(它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步与通信.)

优点：无须复制，快，信息量大；缺点：通信是通过将无法实现共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题；

(5)信号：信号是一种比较复杂的通信方式,对于异常情况下的工作模式，就需要用信号的方式通知进程某个事件已经发生.

(6)socket：可用于不同及其间的进程通信
优点：1）传输数据为字节级，传输数据可自定义，数据量小效率高；2）传输数据时间短，性能高；3) 适合于客户端和服务器端之间信息实时交互；4) 可以加密,数据安全性强
缺点：1) 需对传输的数据进行解析，转化成应用级的数据不同主机的进程间使用socket进行通信(上述方法是相同主机间的进程通信)。

### <u>3.Linux中进程调度算法</u>

在进程的生命周期中，当进程从一个运行状态变化到另外一个运行状态时，就会触发一次调度。

1. 先来先服务调度算法（First Come First Seved, FCFS）：每次调度都是从就绪队列中选择最先进来进入队列的进程，然后一直运行它，直到进程退出或被阻塞，才会继续从队列中选择第一个进程继续运行。当一个长作业(作业就是一个任务进程)先运行了，那么后面的短作业等待时间会很长，所以这个调度算法不利于短作业。

2. 最短作业优先调度算法（Shortest Job First, SJF）：每次都是从就绪队列中优先选择运行时间最短的进程(作业)来运行，有助于提高系统的吞吐量。
3. 高响应比优先调度算法：该算法主要是为了权衡短作业和长作业，每次进行进程调度时，先计算响应比优先级，然后把响应比最高的进程投入运行。响应比计算公式：优先级=(进程等待时间+要求服务时间)/要求服务时间.

4. 时间片轮转法：每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。


### 4.孤儿、僵尸、守护进程

孤儿进程：一个进程退出后，它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程最终会被init进程(进程号为1)所收养。

僵尸进程：指一个进程使用fork函数创建子进程以后，子进程退出了，而父进程并没有调用wait()或waitpid()函数清理子进程的相关信息。那么子进程依然存在于系统中，占用系统资源，这种进程称为僵尸进程。

僵尸进程的解决办法：使用ps aux | grep Z命令查看进程表中的僵尸进程信息，然后使用kill杀死它的父进程，让它变成孤儿进程，然后被系统init进程收养并清理。

所有的子进程没被回收都会变成僵尸进程吗？

不是，init进程不会，任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程的数据结构(它占用一点内存资源)，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。

守护进程：守护进程是一个在后台运行并且不受任何终端控制的进程,(守护进程是有意把父进程结束，被1号init进程收养，init进程是内核启动的第一个用户级进程)。

守护进程创建过程：

1、在父进程中执行fork命令，并退出父进程，这样这个子进程会被init进程托管。

2、子进程中调用setsid()函数创建一个新的会话，并担任该会话组的组长，这样可以使该子进程脱离终端的控制，让这个进程单独成一个进程组，摆脱父进程的影响。

3、因为子进程继承了父进程的工作目录，所以在子进程中调用chdir()函数，改变它的工作目录。

4、子进程中调用umask()函数重设文件权限掩码为0，也是因为子进程继承了之前父进程的掩码所以重设(文件权限掩码是指屏蔽掉文件权限中的对应位)

5、在子进程中关闭任何不需要的文件描述符，防止文件描述符串用

### 5.pthread_detach()和pthread_joined()

pthread_detach()是主线程和子线程分离，子线程结束后，它的资源会被系统自动回收。

pthread_joined()是子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。

### <u>6. CAS操作如何保证原子性</u>

CAS(compare and swap)

CAS(对比并交换）原理：CAS是一个原子指令，用于在多线程环境中实现同步。 它包括三个操作数：内存位置(V)、预期原值(A)、新值(B)。如果内存位置的值与预期原值相匹配，处理器会自动将该位置值更新为新值(说明没被其他线程修改，现在可改)，否则，不做任何操作。这个过程是作为单个原子操作完成的。原子性保证了这个新值是最新的，这个新值在被读取至操作完成过程中不会被其它线程修改。

### <u>7. socket原理</u>

(1)、请说一下socket通信流程/说一下socket通信原理/socket网络编程中用到哪些函数?                                                                                                 先解释下什么是socket套接字：socket是在应用层和传输层之间的一个抽象层，它本质上是编程接口(API)，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用来实现进程在网络中通信。(TCP/IP只是一个协议栈，必须要具体实现，同时还要提供对外的操作接口（API），这就是Socket接口。通过Socket,我们才能使用TCP/IP协议。)

(2)通信流程

<img src="G:\Git\GitProject\Study-notes\八股文\闫博面试整理\秋招复习\知识汇总\图片\socket().jpg" alt="socket()" style="zoom: 33%;" />

服务器端：                                                                                                                                                                          (1)服务器端调用socket()函数，根据IP地址(IPV4、IPV6)、套接字类型(数据报套接字、数据流套接字)、传输协议(TCP、UDP)来创建一个用于监听的套接字。                                                                                                                  (2)服务器端创建完套接字以后，调用bind()函数将创建出来的套接字与服务器一个有效的IP地址和端口号进行绑定，这样流经该IP地址和端口的数据才会交给套接字处理。                                                                                                                               (3)服务器端调用listen()函数让套接字处于监听状态，并设置可以同时和服务器建立连接的客户端的上限数。                                                                                                                   (4)服务器端调用accept()函数阻塞等待，直到接收到客户端的连接请求才解除阻塞，accept()函数会返回一个新的用于和客户端通信的套接字。                                                                                                                                            (5)接下来就是接收到客户端连接以后，和客户端进行通信，调用write()和read()函数进行数据的读写。

客户端：                                                                                                                                                                             (1)客户端也调用socket()函数创建一个用于通信的套接字。                                                                             (2)客户端调用connect()函数，根据服务器IP地址和端口号去尝试连接服务器。调用connect函数将激发TCP的三次握手过程，而且仅在连接建立成功或出错时返回。                                                                                                        (3)连接成功以后，客户端就可以和服务器通信，调用write()和read()函数进行数据的读写。



### <u>9.上下文切换(进程、线程)</u>

各个进程之间是共享CPU资源的，在不同的时候操作系统会在CPU上切换不同的进程或线程，这就是进程/线程的上下文切换。

**上下文切换的步骤：**

1、将前一个CPU的上下文（也就是CPU寄存器和程序计数器里边的内容）保存起来

2、然后加载新任务的上下文到寄存器和程序计数器；

3、最后跳转到程序计数器所指的新位置，运行新任务。

·被保存起来的上下文会存储到**系统内核**中，等待任务重新调度执行时再次加载进来。

·CPU的上下文切换分三种：**进程上下文切换、线程上下文切换、中断上下文切换**。

·进程上下文切换：进程是由内核管理和调度的，进程的切换只能发生在内核态。进程的上下文不但包括虚拟内存、栈、全局变量等用户空间资源，还包括内核堆栈、寄存器等内核空间状态。所以，进程的上下文切换比系统调用多一个步骤：保存当前进程的内核状态和CPU寄存器之前，**先把该进程的虚拟内存、用户栈等保存起来；加载下一个进程的内核态后，还需要刷新进程的虚拟内存和用户栈。**保存上下文和恢复上下文需要内核在CPU上运行才能完成。

·**线程上下文切换：**共享相同的虚拟内存和全局变量等资源不需要修改。线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。

·**中断上下文切换：**中断上下文，需要保存内核态中断服务程序执行所必需的状态，包括**CPU**寄存器、内核堆栈、硬件中断参数等。

### 10.进程地址空间如何保证独立

操作系统通过给每个进程分配一套独立的虚拟地址来将各个进程所使用的地址隔离开来,每个进程都不能访问物理地址，通过OS提供的机制，再将不同进程的虚拟地址和不同内存的物理地址映射起来。



### 11.概述一个消费者-生产者模型是怎样的





# 三线程

### 1.线程间通信方式

因为同一进程下的多个线程是共享内存地址空间的，所以他们可以通过共享全局变量的方式来进行通信，但是要注意线程间的同步问题，来保证共享数据的一致性。

### 2.线程同步原因

多个线程之间共享同一个进程的虚拟地址空间，同一进程下的多个线程会因为共享资源的竞争，导致数据错乱，比如多个线程同时读写同一个共享数据，就可能会发生冲突，所以引入线程同步机制，来解决共享数据的安全问题。

(线程没有单独的地址空间，但是每个线程有自己独立的一套寄存器和栈)

### 3.抽象锁

乐观锁和悲观锁是抽象概念的锁，不是系统自带的api，而是需要我们自己去实现，互斥锁、读写锁、自旋锁都是悲观锁。

乐观锁：乐观锁比较乐观，他认为多线程同时修改共享资源概率比较低，所以先修改共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程修改资源，那么操作完成，如果发现有其他线程修改过这个资源，就放弃本次操作，乐观锁是无锁编程，

悲观锁：悲观锁比较悲观，他认为多线程同时修改共享资源的概率比较高，很容易出现冲突，所以访问共享资源前，先要上锁。

### 5.进程、线程、协程含义

进程是程序运行的实例，**是操作系统分配资源的基本单位。**

线程是轻量级的进程，**是操作系统调度的基本单位。**

协程是轻量级的线程，相当于对一个特殊函数的调用，它不是被操作系统管理的，而是被用户程序所控制。

协程最大的优势是执行效率高，因为它是用户程序来控制的，没有线程切换的开销

### <u>6.进程、线程、协程区别</u>

进程和线程的区别

资源开销方面：因为进程具有一个完整的资源平台，所以在创建进程时，还需要一些资源管理信息(内存、文件这些信息)，而同一进程下的多个线程间是共享代码段、数据段以及文件资源的，所以线程的创建比进程更快，占用CPU的时间更少。同样线程的销毁也要比进程更快，因为线程释放的资源比进程少。另外，每个进程有独立的代码段、数据段和文件资源，而线程间共享这些内容，所以进程切换时的系统开销比线程更大。

影响关系方面：一个进程崩溃后，在保护模式下不会影响其他进程，但是一个线程挂掉，对应的进程都会挂掉了

数据传递方式不同：同一进程下的线程之间共享数据空间(全局变量、静态变量)，所以线程间传递数据简单，不需要经过内核，而进程间的数据相互独立，需要使用通信的方式来相互传递数据(包括，管道、消息队列、共享内存、信号、信号量、套接字)。

线程和协程的区别

协程不需要多线程的锁的机制，因为多个协程同属于一个线程中，不会出现同时写变量的冲突。

进程和线程都是同步机制，协程是异步机制

### 8.多进程与多线程适应场景

1、需要频繁创建和销毁的优先使用多线程。例如：web服务器，来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。

2、需要进行大量计算的优先使用多线程。大量计算会很消耗CPU，切换频繁，这种情况用线程最合适。例如：图像处理，算法处理。

3、进程有独立的地址空间，一个进程崩溃，在保护模式下不会影响其他进程。而线程没有单独的地址空间，多线程共用同一个进程的地址空间，一个线程死掉整个进程就死掉，所以多进程比多线程更安全

4、可以扩展到多机分布的用多进程，多核分布的用多线程。



### 9.多线程共享与不共享资源

同一进程下的多个线程在同一个虚拟地址空间，彼此之间共享文件描述符表、当前的工作目录、共享内存地址空间(包括其中的代码段、数据段以及文件资源)，不共享数据包括：线程ID、栈、寄存器。



### 10.多线程一定比单线程好吗

(举一个单线程比多线程好的例子)

不一定，因为多线程的上下文切换和创建线程都会消耗系统资源。

**CPU密集型：**主要特点是需要进行大量的计算，消耗CPU资源，对视频进行高清解码，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。所以要最高效地利用CPU。计算密集型任务同时进行的数量应当等于CPU的核心数。

IO密集型：主要涉及网络、磁盘IO的任务都是IO密集型任务，这类任务特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成(因为IO的速度远低于CPU的速度)。对于IO密集型任务，任务越多，cpu效率越高，但也有一个限度

# 四.内存分配

### 1.OS申请和管理内存

(1)申请

从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：**brk和mmap**

**brk**是将进程数据段(.data)的最高地址指针向高处移动，通过这种方式扩大进程在运行时的堆大小。                                                                                                                                                                                                               **mmap**是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）寻找一块空闲的虚拟内存，这样可以获得一块可以操作的堆内存。 

一般分配的内存如果小于128k时，使用brk调用来获得虚拟内存，如果大于128k时使用mmap来获得虚拟内存。 进程先通过这两个系统调用获取虚拟内存，获得相应的虚拟地址，然后在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存,并建立虚拟内存和物理内存之间的映射关系，完成内存分配。

(2)管理

**物理内存**：物理内存有四个层次，分别是寄存器、高速缓存、主存、磁盘。

操作系统会对物理内存进行管理，有一个部分称为**内存管理器(memory manager)**，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。

**虚拟内存**：操作系统为每一个进程分配一个独立的地址空间，就是虚拟内存。虚拟内存与物理内存存在映射关系，通过页表寻址可以完成虚拟地址和物理地址的转换。

### <u>2.虚拟内存技术：</u>

![9](G:\Git\GitProject\Study-notes\八股文\闫博面试整理\秋招复习\图片\9.jpg)

·虚存技术允许一个进程部分数据装入内存就可以运行，解决了进程地址空间隔离问题的一种存储管理技术。

·虚拟内存技术为每个进程提供私有的地址空间, 就好像它独占整个内存空间.所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。

·在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码(比如.text .data段)拷贝到物理内存中，只是建立好虚拟内存和磁盘文  件之间的映射就好(叫做存储器映射)，等到运行到对应的程序时，才会通过缺页异常，  来拷贝数据。

### 3.虚拟内存优缺点

优点：

（1）扩大地址空间。每个进程独占一个4G空间，真实物理内存没那么多。

（2）内存保护：防止不同进程对物理内存的争夺，可以对特定内存地址提供写保护，防止恶意篡改。

（3）可以实现内存共享，方便进程通信(两个进程映射同一块物理内存)。

（4）可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。

缺点：

（1）虚拟内存需要额外构建数据结构(虚存的分区)，占用空间。

（2）虚拟地址到物理地址的转换，增加了系统执行时间。

（3）页面的换入换出需要磁盘IO，比较耗时的

（4）一页如果只有一部分数据，浪费内存。

### 4.页面置换算法

简单回顾下虚拟内存技术，基于局部性原理来实现，总结起来就是两句话：

1. 在程序执行过程中，当 CPU 所需要的信息不在内存中的时候，由操作系统负责将所需信息从外存（磁盘）调入内存，然后继续执行程序 
2. 如果调入内存的时候内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存 

整个请求调页的过程大概是这样的：

![img](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20220605121329.png)

那么，**到底哪些页面该被从内存中换出来，哪些页面又该被从磁盘中调入内存呢**？

这就是『页面置换[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)』干的事儿。

(1)最优页面置换算法(opt)

当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。

缺点：这是理想情况，实际系统无法知道一个页面要等多长时间才会被再次访问。可用作其他算法的性能评价依据。

(2)先进先出置换算法（FIFO）

最简单的页面置换算法是先入先出（FIFO）法。总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。因为最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。建立一个FIFO队列，收容所有在内存中的页。被置换页面总是在队列头上进行。当一个页面被放入内存时，就把它插在队尾上。

优点：实现简单                                                                                                    缺点：产生缺页次数相对比较多

(3)最近最少使用（LRU）算法

根据程序**局部性原理**，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。使用一个栈，新页面或者命中的页面移动到栈底，每次替换栈顶的缓存页面。

优点：LRU算法对热点数据命中率是很高的。                                                         缺点：需要寄存器和栈的硬件支持

(4)最不经常访问(LFU)算法

置换最近一段时间访问次数最少的页面。如果数据过去被访问多次，那么将来被访问的频率也更高。每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用  计数的数据块则按照时间排序。每次淘汰队尾数据块。

缺点：排序需要一定的开销。

### <u>5.虚拟内存到物理内存</u>

对于一个内存地址转换，其实就是这样三个步骤：

1. 把虚拟内存地址，切分成页号和对应页内偏移量的组合；
2. 从页表里面，查询出虚拟页号对应的物理内存块号，内存块号*内存块的大小得到物理内存的起始地址；
3. 物理内存的起始地址，加上前面的偏移量，就得到了虚拟内存地址对应的物理内存地址。

### 6.页表

为了知道进程的每个页面在内存中的实际位置，操作系统就为每个进程建立一张虚拟内存到物理内存的映射表，就是页表。

一个进程对应一张页表，页表是记录进程页面和实际存放的内存块之间的对应关系，进程的每一页对应一个页表项，每个页表项由“页号”和“内存块号”（页码号+页框号）组成。(内存块号*内存块的大小=该号内存的起始地址)

**设立页表的原因**：不可能将每一个虚拟内存的字节都对应到物理内存的地址上。进行分页，这样可以减小虚拟内存页对应物理内存页的映射表大小。

### 7.TLB(快表机制)

每次访问一个逻辑地址，都需要查询内存中的页表，由局部性原理可知，可能连续很多次查到的都是同一个页表项，所以引入快表机制(TLB)，它是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

引入快表后，地址变换过程

1.CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。                                                                                   2.如果在快表中找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从快表中取出该页表项中对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访问即可。                                                3.  如果没有找到匹配的页号，则需要访问内存中的页表(慢表)(这是第一次访存)，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，访问该物理地址对应的内存单元(这是第二次访存)。因此，若快表未命中，则访问某个逻辑地址需要两次访问(注意：在找到页表项后，应同时将其存入快表，以便后面可

### 8.MMU和TLB

在CPU内部，有一个部件叫做MMU(内存管理单元)，由它来负责将虚拟地址映射为物理地址,MMU集成了TLB来存储CPU最近常用的页表项来加速寻址，TLB中找不到再去查询内存中的页表，可以认为TLB是MMU的缓存。

### 10.swap分区(交换技术)

##### 10.1 swap分区

swap分区：它是硬盘中一块特殊的空间，多个进程在内存中并发运行，当内存空间紧张时，系统将内存中某些不常用的进程暂时换出外存(硬盘)，把外存中某些已具备运行条件的进程换入内存，操作系统为了保持对这些换出进程的管理，被换出进程的PCB(进程控制块)还是会留在内存当中。

swap分区优点：有了swap分区，通过操作系统的调度，应用程序实际可以使用的内存空间将远超系统的物理内存空间。

swap分区缺点：频繁地读写硬盘，会显著降低操作系统的运行速率，

##### 10.2 交换技术

交换技术：内存空间紧张时，暂时把不用的进程由内存移动到外存，腾出内存空间，需要时再把相应进程全部调入内存的一种存储管理技术，因为换入换出是以整个进程为单位，所以进程大小受到实际内存的限制，一定要小于内存才行。

### 11.分页存储管理思想

把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。这样内存空间就被划分成一个个大小相等的分区，每个分区就是一个“页框”或“内存块”，每个页框有一个编号，即“页框号”或“内存块号”，页框号从0开始的。将用户进程的地址空间也分为与页框大小相等的一个个区域称为“页”或“页面”，每个页面也有一个编号，即“页号”，页号也是从0开始的。操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中，这样进程的页面与内存的页框形成了一一对应的关系。使用分页（Paging）的方式对虚拟地址空间和物理地址空间进行分割和映射，减小换入换出的粒度，提高程序运行效率

### 12.抖动

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动。产生抖动的主要原因是进程频繁访问的页面数高于可用的物理块数(分配给进程的物理块不够)。如果出现了抖动现象，系统会花大量时间去处理进程页面的换入换出，而实际用于进程执行的时间就变得的很少

### <u>13.用户态、内核态</u>

内核态：内核空间存放的是操作系统内核代码和数据，它是被所有程序共享的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还影响其他程序，所以操作系统禁止用户程序直接访问内核空间。

用户态：用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。

##### 1.内核和用户程序共用地址空间

让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。

而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。

##### 2.何时会从用户切换到内核

1.系统调用：用户进程通过系统调用申请操作系统提供的服务程序来完成工作。

2.发生异常：当CPU在执行运行在用户态的程序时，发生某些不可知的异常，就会触发由当前运行进程切换到处理这个异常的内核相关程序，也就到了内核态，比如**缺页异常**。

3.外围设备的中断

**·**当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停下一条要执行的指令，转去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了从用户态到内核态的切换。











操作系统：

* malloc底层实现原理
* 分配内存时什么时候会调用brk？空闲链表的分配和维护是在用户态完成还是内核态完成？
* 讲讲程序中的bss段
* 讲讲程序加载运行的全过程

内存池解决了什么问题






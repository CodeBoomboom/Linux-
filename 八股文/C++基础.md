标下划线的为重点

# 一、C与C++

### 1.C和C+区别：

(1)**C是面向过程编程**，C++是面向对象编程(三大特性)                                                                                                              (2)**C是C++的子集**，C++可以兼容C语言的特性，还增加了一些新特性，比如auto变量、引用、智能指针等                                                                                                                                                                                       (3)**C语言有一些不安全的特性**，比如指针使用潜在的危险性、强制类型转换的不确定性，C++增加了一些特性来改善安全问题，比如C++中有引用、智能指针、cast转换、异常捕获机制try-catch等     

指针使用危险性：指针最初指向一个对象，之后又为这个指针分配其他对象，而原先对象没有释放造成内存泄漏。悬空指针（指针的指向对象已被删除）和野指针（指针变量在定义时如果未初始化）可能会去访问不可控内存空间，破坏正常的数据，引发未知错误。

强制类型转换的不确定性:比如char* 转 int*会导致取得的值很奇怪, 再有int和指针之间的转换是风险极高的一种转换，一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，一般会导致程序崩溃。                                                                                                 (4)**C++代码的复用性高**，因为C++中有重载和模板这些概念 ，在此基础上，实现了方便开发的标准模板库STL                                                                 

模板：有函数模板和类模板。

函数模板是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，用一个虚拟的类型来代替，等发生函数调用时再根据传入的实参的具体类型来逆推出真正的类型。

类模板就是建立一个通用类，它的成员变量类型和成员函数的返回值、形参类型不具体指定，用一个虚拟的类型来代替，使用类模板定义对象时，再根据实参类型来取代类模板中的虚拟类型。

重载：同一作用域下的同名函数，才存在重载关系。它的特点是函数名相同，参数的类型、数量或者顺序要有所不同，函数的返回值不能够作为函数重载的条件。

### 2.面向对象和面向过程：

面向过程:是根据业务逻辑来分析解决一个问题都需要哪些步骤，用函数把这些步骤依次实现。

面向对象:把构成问题的事物抽象成各个对象，把事物的属性变量和操作属性变量的函数封装进去，这样在写代码时以对象为核心，调用对象的成员方法就可以完成一些事情。

### <u>3.C和C+的结构体struct区别</u>

1.C中结构体没有成员函数和静态成员，C++中结构体可以有

2.C中结构体中成员默认的访问权限是public且不可更改，C++中也是public但可以更改为protected、private

3.C中结构体不可以继承，C++中结构体可以从类或其他结构体继承

4.C中结构体不能直接初始化数据成员，C++中可以

5.C中结构体在使用时要加上struct关键字，或用typedef取别名，C++可以省略struct关键字，直接使用

### <u>4.简述C++从代码到可执行二进制文件的过程(动静态链接)</u>

预编译、编译、汇编、链接。

1. 预编译：这个过程主要的处理操作如下：

   （1） 将所有的#define删除，并且展开所有的宏定义

   （2） 处理所有的条件预编译指令，如#if、#ifdef

   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

   （4） 过滤所有的注释

   （5） 添加行号和文件名标识。

2. 编译：这个过程主要的处理操作如下：

   （1） 词法分析：将源代码的字符序列分割成一系列的记号。

   （2） 语法分析：对记号进行语法分析，产生语法树。

   （3） 语义分析：判断表达式是否有意义。

   （4） 代码优化：

   （5） 目标代码生成：生成汇编代码。

   （6） 目标代码优化：

3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

   链接分为静态链接和动态链接。

   静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

   而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

### 5.main()执行前后的操作

(1)main()函数执行前会执行一些初始化的操作

设置栈指针(为栈分配相关的位置，用来放一些局部变量和其他数据)

初始化全局变量和静态变量(即data段的内容)（C）

对未设置初值的全局变量赋初值(数值型short，int，long等为0，指针为NULL等，即.bss段的内容)

在main之前还会调用全局对象的构造函数

给main()函数传递参数，argc，argv(第一个**argc表示参数的个数**；第二个参数是是指向字符串的指针数组，其中**argv[0]为自身运行目录路径和程序名**，argv[1]指向第一个参数、argv[2]指向第二个参数)

(2)在main函数执行后会调用全局对象的析构函数； 

### 6.++i和i++

1. **赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。

2. **效率不同**：后置++执行速度比前置的慢。

3. **i++ 不能作为左值，而++i 可以**：

   ```c
   int i = 0;
   int *p1 = &(++i);//正确
   int *p2 = &(i++);//错误
   ++i = 1; //正确
   i++ = 1; //错误
   ```

4. 两者都不是原子操作。

### 7.说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。

```c
1. const int a;     //指的是a是一个常量，不允许修改。
2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
3. int const *a;    //同const int *a;
4. int *const a;    //a指针所指向的内存地址不变，即a不变
5. const int *const a;   //都不变，即（*a）不变，a也不变
```

### 8.简述C++有几种传值方式，之间的区别是什么？

传参方式有这三种：**值传递、引用传递、指针传递**

1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
2. 引用传递：形参在函数体内值发生变化，会影响实参的值；
3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

### <u>9.四种类型转换运算符</u>

C++中四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast。

**1、const_cast**

const_cast用来将const/volatile [ˈvɑːlətl] 类型转换为非const/volatile  [ˈvɑːlətl] 类型。具体用法如下：

(1)可将常量指针转化成非常量的指针，并且仍然指向原来的对象
(2)可将常量引用转换成非常量的引用，也是仍然指向原来的对象
(常量对象或者是基本数据类型不允许转化为非常量对象，**只能通过指针和引用**来修改)

**2、static_cast**   [ˈstætɪk] 

static_cast是“静态转换”，它是在编译期间转换，转换失败会抛出编译错误，主要用于明确**隐式转换**，它**只支持低风险**的转换操作，不支持引用/指针，如:

(1)C语言中原有的隐式转换，如short转int、int转double、const转非 const、(向上转型)等；

(2)void指针和具体类型指针间的转换，如void指针转int *、char转void *等；

不可用于高风险转换，如：

(1)两个不同的具体类型指针之间的转换

(2)整型和指针之间的互相转换

(3)不同类型的引用之间的转换

static_cast**还可用于类层次结构中父类和子类间的指针或引用的转换**。进行**上行转换（把子类的指针或引用转换成父类表示）**是安全的，进行下行转换（把父类指针或引用转换成子类表示），子类可能包含的成员更多，占用内存更大，把父类转子类很可能访问到了父类不该访问的地方，会越界。由于static_cast没有动态类型检查，所以不安全，结果未知；

**3、dynamic_cast**    [daɪˈnæmɪk] 

dynamic_cast是在类的继承层次间进行类型转换时使用，允许向上转型，也允许向下转型。因为向上转型子类转父类是安全的，所以使用dynamic_cast和static_cast的效果相同，使用dynamic_cast还有额外开销，所以向上转型使用static_cast就可以了；向下转型有可能不安全，因为父类有可能去访问子类扩展的成员，这就要借助 RTTI机制进行检测，确定安全才能转换成功，**转型不成功会返回一个空指针**。使用dynamic_cast前提是：**父类必须要有虚函数**，因为RTTI运行时的类型检测是依赖于虚函数表的实现。

1. 常用于子类和父类之间的类型转换（指针/引用）
2. 有返回值，可以进行类型（安全）检查

**RTTI：**

编译器会把存在继承关系的类的类型信息用指针“连接”起来，形成一个继承链，dynamic_cast 在程序运行过程中遍历这个继承链，如果遍历过程中遇到了要转换的目标类型，就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，就转换失败。 

**4、reinterpret_cast**  [ˌriːɪnˈtɜːrprət] 

reinterpret_cast和C语言显示强转本质相同。可以用在不同类型指针之间，不同类型引用之间，int和指针之间的转换等，但是因为是强转，所以转换后可能会出问题，尽量少用；

### 10.封装、继承、多态

(1)封装

将客观事物抽象成类，并把类的属性和行为按照不同的访问权限封装到类的里面，有三种访问权限:public、private和protected。

public作用域下的成员(包括成员函数和成员变量)，类内成员可以访问，也允许类外的对象访问。

private作用域下的成员(包括成员函数和成员变量)，只限于类内成员可以访问。

protected作用域下的成员(包括成员函数和成员变量)，类内成员和派生类成员都可以访问，但不允许类外的任何访问。

(2)继承

继承是我在创建一个新的类时可以先获取到现有类的成员函数和成员对象，然后在这个基础上再定义自己的新成员，(现有类是基类，新建类是派生类)。有三种继承方式：公有继承、私有继承和保护继承。基类的私有成员，无论派生类使用哪种继承方式都无法访问。

在公有继承(public)方式下：

基类中所有public和protected权限下的成员在派生类中仍为public和protected属性。基类中所有private权限下成员在派生类中不能访问。

在保护继承(protected)方式下：

基类中所有public和protected权限下的成员在派生类中都为protected属性。还是基类中所有private权限下成员在派生类中不能访问。

在私有继承(private)方式下：

基类中所有public和protected权限下的成员在派生类中都为private属性。仍然是基类中所有private权限下成员在派生类中不能访问。

(3)多态

是指基类指针可以按照基类的方式去做事，也可以按照派生类的方式去做事，它有多种形态，多态可分为静态多态(也叫编译时的多态，地址早绑定)和动态多态(也叫运行时的多态，地址晚绑定)，静态多态主要是指对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数，(因此叫编译时的多态)；动态多态和继承、虚函数等有关，在程序运行时才能确定是使用基类成员函数还是派生类成员函数，因此叫运行时的多态。

**看这里**多态是通过虚函数来实现的，有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态**

**多态原理：**

一个类中如果包含了一个虚函数，在编译时会生成一个虚表，子类继承了父类的虚函数，每个子类也会生成一个自己的虚表，这样子类和父类在创建对象时，在对象的内存模型中，都会有一个虚表指针，指向类的虚表，类的所有对象共享这一个虚表，但类的每个对象都有一个属于自己的虚表指针，基类指针指向不同的对象去调用非静态成员函数时，会把这个对象的地址也就是this指针传递给对象的虚表指针，到虚表中找到对应的虚函数入口地址，然后执行实际被调用的虚函数。

### 11.继承中构造和析构顺序

基类构造函数》子类成员变量的构造函数》子类的构造函数

析构顺序与构造正好相反

### 12.友元函数作用及场景

作用：友元是不同类的成员函数之间或者类的成员函数与一般函数之间进行数据共享的这么一个机制把。通过友元，一个普通函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。

使用场景：普通函数定义为友元函数，使普通函数能够访问类的私有成员。

### 13.定义和声明的区别

变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量只能定义一次。

变量声明：不会为变量分配存储空间，用于向程序表明变量的类型和名字，程序中，可以声明多次。







# 二、关键字及运算符

### <u>1. C++中struct和class关键字的区别</u>

(1)类中成员的默认访问权限是private，结构体中成员默认访问权限是public                                                                                                        (2)类默认的继承方式是私有继承，结构体默认的继承方式是公有继承                                                                                                                                                  (3)类可以使用模板，结构体不可以(类模板:是对一批仅仅成员数据类型不同的类的抽象)         (4)class 关键字可以用于定义模板参数，就像 `typename`，而 `struct` 不能用于定义模板参数                                                                                                         

### <u>2.extern</u> 

声明外部变量【在函数或者文件外部定义的全局变量】

**extern"C"**

C++支持函数重载，编译器编译函数的过程中会根据函数名和函数形参列表重新命名；但是C语言不支持函数重载，编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

所以当我们想用C++代码调用C语言代码时，要加上extern "C"，这样会告诉编译器这部分代码按C语言而不是C++的方式进行编译。

这个功能主要用在下面的情况：

1.C++代码调用C语言代码

2.在C++的头文件中使用(C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的)

3.在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到

### <u>3.static关键字</u>

##### 1 static作用

(1)static关键字修饰的变量存储在全局区，默认初始化为0                                                                                                                                (2)static修饰的函数或变量只能在本文件中使用                                                                                                                                                     (3)static修饰的成员变量或成员函数，它们都是类的一部分，这个类的所有对象都共享这个静态成员变量和静态成员函数。

##### 2 (静态)全局变量/函数

(1)静态全局变量和全局函数都是在全局区                                                                                                                                                              (2)静态全局变量(函数)的作用域仅限于当前文件，全局变量(函数)的作用域是整个源程序，包括其他源文件。

##### 3 (静态)局部变量

(1)静态局部变量在全局区，局部变量在栈区                                                                                                                                                          (2)静态局部变量生命周期是整个程序运行结束，局部变量生命周期是随着函数的结束而结束                                                                              

(3)定义静态局部变量默认初始化为0，定义局部变量默认初始化一个随机值                                                                                                         (4)静态局部变量只初始化一次，而局部变量每调用一次函数都会重新初始化。                                                                                                          静态局部变量特点：只初始化一次，整个程序结束后才被操作系统回收，只能在定义的函数内使用。

##### 4 (静态)成员变量/函数

静态成员变量                                                                                                                                                                   (1)static修饰的成员变量，存放在静态存储区(全局区)，该类的所有对象都共享同一个静态成员。                                                                                                                                           (2)静态成员变量因为存储在全局区/静态区，所以在编译阶段就为它分配了内存                                                                                                   (3)静态成员变量在类内声明，类外初始化

静态成员函数                                                                                                                                                                                                                                                                                                          (1)静态成员函数也是存放在静态全局区，被该类的所有对象所共享                                                                                                                              (2)普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员

### 4.内联函数(inline)

请你说说内联函数，为什么使用内联函数？需要注意什么？：

1.(C++内联函数通常与类一起使用。)内联函数是在编译阶段，编译器会把这个函数的代码副本放到每个调用该函数的地方。如果想把一个函数定义为内联函数，函数名前要加关键字inline.

2.正常的函数调用是需要一定的时间开销，需要**寻址（函数入口地址）**，如果函数体本身很简单，函数调用的时间开销可能远大于函数体执行的开销，这个时候就比较适合使用内联函数。内联函数是以空间换时间，不需要寻址，它会在函数调用的地方直接用函数体进行替换。

3.但是如果函数体的代码很长，使用内联函数对内存资源消耗比较大，或者函数体内有循环，那么执行函数体内代码的时间就要比函数调用的时间长，这些情况就不适合使用内联函数了。



### 5.内联函数inline和宏函数define的区别

1.宏函数本质上不是函数，是预处理器用复用代码的方式代替函数调用，省去函数的出栈入栈过程，这样可以提高效率。而内联函数本质是一个函数，它一般都是函数体代码比较简单的函数。

2.宏函数是在预处理阶段，把所有宏名用宏体来替换(#define a a*b);内联函数在编译阶段，编译器在每个内联函数被调用的地方直接把内联函数的内容展开。

3.宏函数没有类型检查，无论对错都直接进行替换；内联函数在编译阶段会进行类型的检查。

### 6.const和define的区别

const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

1. const生效于编译的阶段；define生效于预处理阶段。
2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
3. #define只是简单的字符串替换，没有类型检查。而const定义的常量有对应的数据类型，会进行类型检查，可以避免一些低级的错误。 
4. const常量可以进行调试，define不能进行调试，因为在预编译阶段就已经替换掉了

### 7.const*和 *const的区别

```c
//const* 是常量指针，*const 是指针常量

int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变
```

### <u>8.  const和volatile</u>

##### 1.volatile  [ˈvɑːlətl]

volatile关键字修饰的变量，会让系统总是从它所在内存读取数据，因为cpu到寄存器读数据比到内存里读数据更快，在程序运行的时候，有些频繁使用的变量编译器会对它做优化，把这个变量装入寄存器里。在多线程下，如果两个线程都要去访问某一个共享变量，一个线程使用的是内存中的这个变量的值，另一个线程使用的是寄存器中的这个变量的值，内存和寄存器中这个变量的值可能不同，就会造成执行错误，**所以多线程下要使用volatile来修饰那些被多个线程共用的变量。**

(在多线程下，线程A先将共享变量读入寄存器，对其执行加1操作并写回内存，然后线程B再将共享变量读入寄存器，加1后写回内存，这样是没有任何问题，问题在于线程是并发执行，可能线程A还未将累加后的数据写回内存，线程B就已经开始读取数据到寄存器，这样线程B会读到修改之前的旧数据)

##### 2.const

(1)使用const,可以防止变量被改变，在定义const变量的时候，需要对它初始化，因为以后就没有机会再去改变它了；

(2)在函数声明时，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变它的值

(3)对于类的成员函数，如果指定为const类型了，就表明这是一个常函数，它不能修改类的成员变量，类的常对象只能访问类的常成员函数；

(4)const类型变量还可以通过类型转换符const_cast将const类型转换为非const类型

(5、6可不说)

(5)const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员.

(6)非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；

### <u>9.C++中class和struct</u>

(1)类中成员的默认访问权限是private，结构体中成员默认访问权限是public                                                                                                        (2)类默认的继承方式是私有继承，结构体默认的继承方式是公有继承                                                                                                                                                  (3)类可以使用模板，结构体不可以(类模板:是对一批仅仅成员数据类型不同的类的抽象)

### <u>10.C和C+的结构体struct区别</u>

1.C中结构体没有成员函数和静态成员，C++中结构体可以有

2.C中结构体中成员默认的访问权限是public且不可更改，C++中也是public但可以更改为protected、private

3.C中结构体不可以继承，C++中结构体可以从类或其他结构体继承(默认公有继承)

4.C中结构体不能直接初始化数据成员，C++中可以

5.C中结构体在使用时要加上struct关键字，或用typedef取别名，C++可以省略struct关键字，直接使用

### <u>11.struct和union</u>

1.联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。
2.对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体，当对不同成员赋值时，相互之间不影响。

### 12.大端小端及其判断

小端存储是指字节数据的低位存储在低地址

大端存储是指字节数据的低位存储在高地址

·**主机大多数是小端数据**

**·网络字节序为大端数据**

判断：可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储





# 三、指针相关

### 1.指针大小

在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8

```cpp
// 指针
// 指向对象的指针
int* p = new int(0);
delete p;
// 指向数组的指针
int* p1 = new int[10];
delete[] p1;
// 指向类的指针：
string* p2 = new string;
delete p2;
// 指向指针的指针（二级指针）
int** pp = &p;
**pp = 10;


int a[3][4];  
int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组
p = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]
              //所以数组指针也称指向一维数组的指针，亦称行指针。
//访问数组中第i行j列的一个元素，有几种操作方式：
//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。
//这几种操作方式都是合法的。
```







### <u>2.野、悬空和void指针</u>

(1)、野指针：野指针一般指在定义时未初始化的指针，指针变量存放的地址是随机的。比如：char*p,但是static关键字修饰的指针变量未初始化时默认为0，它不是野指针，比如static char *p

(2)、悬空指针：指针最初所指的内存被释放后，指针仍然指向原来分配给它的这块空间，这个时候该指针就是悬空指针。

无论是野指针还是悬空指针，它们都是指向了一段不安全不可控的内存空间，可能会破坏正常的数据，引发一些未知错误。

**如何避免使用野指针？**在定义指针时就对其进行初始化，如果不能确定初始化的值，可以对该指针初始化为nullptr。

**如何避免使用悬空指针？**指针所指空间被释放后，给该指针赋值为nullptr。或直接使用智能指针就不会出现空指针和野指针的情况。(因为在智能指针的构造和析构函数中有相应的处理。)

(3)、void指针:表示指针指向的数据类型不确定，在之后使用过程中强制转换它的类型。

### 4.数组指针和指针数组

在32位平台下无论什么类型的指针，利用sizeof来求它的长度时，都是四个字节

在64位平台下都是8个字节。

指针数组：是数组，只是数组中存放的元素都是指针变量。

数组指针：是指针，它指向的是一个数组。

### 5.函数指针和指针函数

指针函数：是函数，只是函数的返回值是一个指针变量

函数指针：是指针，指针指向的是一个函数，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。常用于**回调**。定义形式如下：

```cpp
int func(int a); 
int (*f)(int a); 
f = &func;
```

### 6. const和指针 常量指针和指针常量

const离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针所指的数据，如果变量名远近都有const，就是同时修饰指针变量以及它指向的数据。

指针常量：char* const p//地址(指针本身)不可以修改，指针指向的内容可以修改。

常量指针：const char*p//指针本身可以修改(指向不同的数据)，但他们指向的数据本身不可以修改

### 7. this指针

每一个非静态成员函数只会诞生一份函数实例，多个同类型的对象会共用一块代码，那这块代码就需要区分是哪个对象调用的自己。this指针指向被调用的成员函数所属的对象，它是隐含在每一个非静态成员函数内的一种指针。this指针主要有两个用途：

(1)当形参和成员变量同名时，可用this指针来区分                                                                                                                (2)在类的非静态成员函数中返回对象本身，可使用return *this

### 8.指针和迭代器区别

迭代器实际上是一个类模板，它是对指针的封装，模拟了指针的一些功能，重载了指针的一些操作符，比如解引用*、指针指向操作符->、++、--等。

### 9.使用指针需要注意什么

1. 定义指针时，先初始化为NULL，避免“野指针”。
2. 用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。
3. 不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。
4. 避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作
5. 动态内存的申请与释放必须配对，防止**内存泄漏**
6. 用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“悬空指针”















# 四、内存分配相关

## <u>1 C++五大分区(内存管理)</u>

一个C/C++编译的程序占用的内存分为：堆区、栈区、全局区(静态区)、常量区、程序代码区。

**栈**：由编译器自动分配和释放，存放函数运行时分配的局部变量、形参、返回数据、返回地址等，它的操作类似于数据结构中的栈(是一块连续的内存)。

**堆**：堆区是动态分配，程序运行时用new或malloc来申请内存，需要程序员负责释放，如果程序员没有释放，程序结束后，操作系统会自动回收。(频繁的分配和释放不同大小的堆区空间将会造成内存碎片)

**全局区(静态区)**：全局区分为已初始化全局区(.data段)，存放初始化后的全局变量和静态变量，未初始化全局区(.bss段)，存放未初始化的全局变量和静态变量。这块内存有读写权限，所以全局区中的数据在程序运行期间可任意改变。这块内存是在程序编译阶段分配好的，在程序结束后会由操作系统回收。

**常量区**：存放一般的常量、字符串常量等，这块内存只有读权限、没有写权限，所以它们的值在程序运行期间不能改变，程序结束后由操作系统回收。

**代码区**：存放二进制代码。(不允许修改，但可以执行)

最后还有一个**文件映射区**，位于堆和栈之间

![image-20201219142935577](https://static.nowcoder.com/images/activity/2021jxy/c/assert/2.png)

## 2.静态局部变量，全局变量，局部变量的特点，以及使用场景

1. **首先从作用域考虑**：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。

   全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。

   静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。

   局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。

   静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

2. **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

3. **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。

4. **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。

## <u>3.堆和栈区别</u>

1.管理方式不同：栈由编译器自动申请和释放内存，堆区需要程序员手动申请和释放

2.碎片问题：栈区和数据结构中栈的原理一样，在弹出一个元素之前，前一元素已经弹出了，不会产生碎片(内存连续)。但堆区如果频繁的分配和释放不同大小的堆区内存会造成内存碎片。(堆区内存不连续)

3.生长方向不同：堆向上，向着内存地址增加的方向生长。栈向下，向着内存地址减小的方向生长。(操作系统规定的)

4.堆空间大，栈空间小，32位环境下虚拟地址空间大小约为4G，其中堆空间大小约为2G左右。栈空间大小约为1M。

## <u>4. new/delete和malloc/free</u>

(可作为C和C++内存分配区别的一个点)

1. new和delete是操作符，malloc和free是函数。

2. 使用new创建对象会调用构造函数，使用delete释放对象时会调用析构函数，malloc和free是没有构造函数和析构函数的

3. 使用malloc需要指定申请的空间大小，还要对返回回来的void*类型指针进行强制类型转换，new这些都不需要(会调用构造函数)

4. malloc申请完空间后要判空，因为它设定内存分配失败会返回空指针，而new申请空间后不用判空，new如果发生错误会抛出异常。(分配失败抛出异常std::bad_alloc)

   ![image-20220803091432557](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220803091432557.png)

## 5.new和delete实现原理

new实现过程：第一步调用operator new()的标准库函数，申请一块足够大的内存空间，用来保存指定类型的对象；第二步，编译器运行相应的构造函数去构造这些对象，并进行初始化。第三步，对象被分配完空间并完成构造后，返回一个指向该对象的指针。(operator new()操作的内部是调用了malloc()函数)。

delete实现过程：运行指针所指向对象的析构函数(或所指数组中的元素执行对应的析构函数)，然后通过调用operator delete(或operator delete[])的标准库函数释放所用内存。(operator delete()操作的内部是调用了free()函数)。

## 6. delete和delete[]的区别

delete用来释放单个对象所占的空间，只会调用一次析构函数；

delete[]用来释放数组空间，会对数组中的每个成员都调用一次析构函数。

## <u>7.malloc申请内存时，OS怎么做的</u>

malloc整体思想是先向操作系统申请一块大小适当的内存，然后自己管理，(从操作系统的角度看)，malloc是通过brk()和mmap()这两个系统调用实现的：

(1)brk是将进程数据段(.data)的最高地址指针向高处移动，通过这种方式扩大进程在运行时的堆大小。                                                                                                                                                   (2)mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）寻找一块空闲的虚拟内存，这样可以获得一块可以操作的堆内存。 

一般分配的内存如果小于128k时，使用brk调用来获得虚拟内存，如果大于128k时使用mmap来获得虚拟内存。 进程先通过这两个系统调用获取虚拟内存，获得相应的虚拟地址，然后在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存,并建立虚拟内存和物理内存之间的映射关系，完成内存分配。

**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址

## 8.**常见的内存错误及其对策**

（1）内存分配未成功，却使用了它。

（2）内存分配虽然成功，但是尚未初始化就引用它。

（3）内存分配成功并且已经初始化，但操作越过了内存的边界。

（4）忘记了释放内存，造成内存泄露。

（5）释放了内存却继续使用它。

对策：

（1）定义指针时，先初始化为NULL。

（2）用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。

（3）不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。

（4）避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作

（5）动态内存的申请与释放必须配对，防止**内存泄漏**

（6）用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”

（7）使用智能指针。

## 9.内存泄漏/内存溢出

内存溢出:指程序要使用的内存超过了系统实际分配的内存。 

内存泄漏:是指在堆区申请的内存使用完以后没有释放，内存泄漏堆积的后果就是内存溢出。

## <u>10.C++内存泄漏</u>

### 10.1 内存泄漏情况

1.使用new在堆区创建完数据以后，没有使用delete释放，造成内存泄漏

2.当用new创建了一个对象数组，释放数据时只调用了delete没有调用delete[]，这样只有数组中第一个对象执行了析构函数，数组中其他对象的内存没有回收，造成内存泄漏

3.基类的析构函数没有设置成虚函数，在实现多态的时候，如果子类有堆区数据，用delete删除指向子类的基类指针，子类的析构函数无法被调用，导致子类对象无法释放，造成内存泄漏

4.一个指针已经指向了一块内存空间，现在为这个指针重新赋值，导致该指针原来指向的那块内存空间无法找到，造成内存泄漏。

### 10.2 防止内存泄漏的方法

(1)养成new和delete运算符配对使用的习惯，在自由存储空间上动态分配，使用完毕后释放。

(2)使用C++提供的智能指针，可以自动完成释放资源的操作。

(3)或者借用智能指针的思想，将内存分配和释放的相关代码封装到类中，在构造的时候申请内存，析构的时候释放内存。

### 10.3 内存泄漏检查

可以使用valgrind内存检查工具，没具体用过，内存泄漏原因一般是这几种，写代码时养成好的习惯，避免这几种情况应该就不会出现内存泄漏了。

自己动手尝试过，但是复杂情况下不适用的方法，linux中，利用gdb，在调用某个函数之前设置一个断点，然后调用malloc_stats()系统函数来查看当前进程内存使用情况。在函数执行完成后(gdb下使用n，不进入函数体)，再次调用malloc_stats()系统函数查看当前进程内存使用情况，比较它们之间的差值判断是否有内存泄漏。

## 11.段错误发生和检测

段错误就是说访问的内存超出了系统所给这个程序的内存，一般有三种情况

(1)访问的内存可能是不存在的，或者是受系统保护的，如果用户访问到，就会发生段错误

(2)数组越界，访问到了不属于你的内存

(3)访问只读常量区的数据，并对数据进行修改。

检测方法：当一个进程发生段错误时，Linux系统会给它发送**SIGSEGV**(segmentationviolation)信号，通过gdb查看调试信息文件core即可检测到段错误。

## 12.atomoic六种内存顺序

有六个内存顺序选项可应用于对原子类型的操作：

1. memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。
2. memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。
3. memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。
4. memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。
5. memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。
6. memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个"获取释放"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。

除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。



## <u>13.字节对齐</u>

字节对齐是一种空间换时间的策略，要使变量的起始地址是该变量所占内存大小的整数倍，目的是将一个数据尽量放在cpu寻址的一个步长里，避免跨步长存储，这样CPU处理数据的效率更高。

举例：一个变量占用n个字节，它的起始地址就是n的整数倍。比如一个4字节int类型变量，它的起始地址应该是可以被4整除的。如果是结构体变量，它的起始地址是其最宽数据类型成员的整数倍。

为什么要字节对齐？

字节对齐是为了提高CPU访问效率，以32位的cpu为例，它一次可以处理4字节数据(64位是8字节)，实际寻址的步长就是4个字节，也就是只对编号为4的倍数的内存进行寻址，一个int类型的变量占4个字节，如果它的地址编号为从4开始，cpu寻址一次就可以读到这个数据，如果它的地址编号从5开始，cpu就要寻址两次，第一次从编号4开始读取四个字节得到数据的前半部分，然后从编号8开始进行一次寻址，读取四个字节，得到数据后半部分，将两部分拼接一起，得到整个数据。

## <u>14.结构体字节对齐</u>

32/64位系统各类型变量所占字节数

![数据类型](G:\Git\GitProject\Study-notes\八股文\闫博面试整理\秋招复习\知识汇总\图片\数据类型.jpg)

说一下结构体的对齐规则。

一、结构体对齐规则首先要看有没有用*#pragma pack宏*   [p'ræɡmə]声明，这个宏可以改变对齐规则，有宏定义的情况下结构体的自身宽度就是宏上规定的数值大小，所有内存都按照这个宽度去布局，#pragma pack 参数只能是 '1', '2', '4', '8', or '16'。

二、在没有#pragma pack这个宏的声明下，遵循下面三个原则：

**1.**结构体中元素按照定义顺序从结构体首地址开始依次置于内存中，元素会放在自身对齐大小的整数倍地址上。（也就是成员的首地址是自身大小的整数倍）这里说的地址是元素在结构体中的偏移量，结构体中首地址偏移量为0。

**2.**基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小是它元素中最大对齐元素的对齐大小。

**3.**结构体的总大小，应该为所有元素中最大对齐大小的整数倍，如果不满足，结构体要对齐到最大对齐大小的整数倍，填充的字节空间放置到结构体末尾

关于1：(char型，自身对齐值为1，short型为2，对于int,float类型，自身对齐值为4，double型，自身对齐值为8，单位字节。)

关于2：(比如结构体中有char、int、double，那结构体对齐大小就是和double一样为8，如果结构体中有数组，将数组看做是连续数个相同类型的元素即可，char name[10]，长度最长，是10，那是不是要以 10 对齐？”不是，char a[10] 的本质是10 个char 变量，所以就把它当成10个 char 变量看就行了)。

比如结构体B包含结构体A，结构体A应该从偏移量为A内最大成员整数倍开始存储。(struct B里面存放struct A，A里有char、int、double，A中最大对齐元素为double，所以A应该从8的整数倍开始存)

关于3:

```c++
struct A
{
    char c;//从首地址0开始，占一个字节	 0-1
    double d;//放在自身对齐大小的整数倍地址上(第一个char到1，往后填充7个字节，从地址8开始，占8个字节，到16)			    8-15
    int i;//从16开始占4个字节，但还要填4个字节凑够24(结构体大小对齐到结构体最大对齐大小8的整数倍)						  16
};//17-24
```

sizeof(A)=24而非20，三个元素占据20字节空间，三个元素中最大对齐大小为8，所以需要在结构体的尾部填充4个字节的空间凑成8的倍数，此时整个结构体的大小为24字节。

再来个例子

```cpp
struct B
{
  int a;//占4个字节   0-3
  A a; //结构体A的对齐大小为其内部最大元素的对其大小，即double：8，所以要从第8个位置开始对齐			8-31
};//32
//最终结果sizeof(B) = 32
```

## 15. C+空结构体大小为1

为了满足C++标准规定的不同对象不能有相同地址，C++编译器保证任何类型对象大小不能为0。**C++编译器会在空类或空结构体中增加一个虚设的字节（有的编译器可能不止一个），以确保不同的对象都具有不同的地址**

## 16. 类大小计算

说明：类的大小是指类的实例化对象的大小，用sizeof对类型名操作时，结果是该类型的对象的大小。

计算原则：

(1)遵循结构体的对齐原则。
(2)与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。
(3)虚函数对类的大小有影响，是因为虚函数表指针的影响。（虚函数表指针一般为8，直接加到
(4)虚继承对类的大小有影响，是因为虚基表指针带来的影响。
(5)空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。

```cpp
class A {
    int a;
};

class B:virtual public A{
    virtual void myfunB(){}
};

class C:virtual public A{
    virtual void myfunC(){}
};

class D:public B,public C{
    virtual void myfunD(){}
};
//A的大小为int大小加上虚表指针大小。虚表指针为8，字节对齐后A的大小为8+8
//B，C中由于是虚继承因此大小为int大小加指向虚基类的指针的大小。
//B,C虽然加入了自己的虚函数，但是虚表指针是和基类共享的，因此不会有自己的虚表指针，他们两个共用虚基类A的虚表指针。 B/C的虚基类指针+虚表指针+A类int变量大小=8+8+8
//D由于B,C都是虚继承，因此D只包含一个A的副本，于是D大小就等于int变量的大小+B中的指向虚基类的指针+C中的指向虚基类的指针+一个A虚表指针的大小,由于字节对齐，结果为8+8+8+8=32
```









# 五、多态与虚函数

### <u>1. C++多态原理</u>

(C++虚函数原理/讲讲虚函数运行机制/讲讲虚函数如何解析)

一个类中如果包含了一个虚函数，在编译时会生成一个虚表，子类继承了父类的虚函数，每个子类也会生成一个自己的虚表，这样子类和父类在创建对象时，在对象的内存模型中，都会有一个虚表指针，指向类的虚表，类的所有对象共享这一个虚表，但类的每个对象都有一个属于自己的虚表指针，基类指针指向不同的对象去调用非静态成员函数时，会把这个对象的地址也就是this指针传递给对象的虚表指针，到虚表中找到对应的虚函数入口地址，然后执行实际被调用的虚函数。

实现多态的三个条件：1.必须有继承关系2.基类中必须包含虚函数，派生类一定要对基类中的虚函数进行重写3.通过基类对象的指针或引用指向调用虚函数

生成子类虚函数表需要三个步骤：

第一步，将父类虚函数表内容拷贝到子类虚函数表上；

第二步，将子类重写的虚函数覆盖掉表中父类的虚函数;

第三步，如果子类有新增加的虚函数，按声明顺序加到最后。


















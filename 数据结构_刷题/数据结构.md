# 栈与队列

栈：先进后出

队列：先进先出

![image-20220228220653706](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220228220653706.png)

栈stack是容器适配器，队列queue也是容器适配器，在STL都是基于deque实现，也可以基于vector、list实现



# 二叉树

## 树

数存储结构：“一对多”

![img](http://c.biancheng.net/uploads/allimg/190427/0944301493-0.png)

**树根结点**、**父节点**（双亲节点）、**子节点**、**兄弟节点**、**叶子节点**（结点没有任何子结点）

**子树**、**空树**（空树中没有结点）

对于一个结点，拥有的子树数（结点有多少分支）称为结点的**度**（Degree）。

结点的**层次**：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。

如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为**有序树**；反之称为**无序树**。

由 m（m >= 0）个互不相交的树组成的集合被称为**森林**。

## 二叉树

满足以下两个条件的树就是**二叉树**：

1. 本身是有序树；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

二叉树**性质**：

1. 二叉树中，第 i 层最多有 2^(i-1) 个结点。
2. 如果二叉树的深度为 K，那么此二叉树最多有 2^K-1 个结点。
3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为**满二叉树**。

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为**完全二叉树**。



## 二叉树的递归遍历

递归三要素

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

遍历：

按照 "从上到下，从左到右" 的顺序遍历整棵二叉树。

![img](http://c.biancheng.net/uploads/allimg/190427/094P344W-2.gif)

整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 3 中的节点 2 为例，如图 4 所示，它被经过了 3 次。

![img](http://c.biancheng.net/uploads/allimg/190427/094P36220-3.gif)

这也就引出了以下 3 种遍历二叉树的算法：

1. 先序遍历：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 中的 ①）；
2. 中序遍历：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 中的 ②）；
3. 后序遍历：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 中的 ③）；

### 先/前序遍历

1. **确定递归函数的参数和返回值**：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：

```cpp
void traversal(TreeNode* cur, vector<int>& vec)
```

2. **确定终止条件**：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：

```cpp
if (cur == NULL) return;
```

3. **确定单层递归的逻辑**：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：

```cpp
vec.push_back(cur->val);    // 中
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```

完整代码

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

### 中序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```



### 后序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```



## 二叉树的迭代遍历

### 前序遍历

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

![中序遍历流程图](https://pic.leetcode-cn.com/6233a9685447d0b4d7b513f739151ca065e5697e24070bcafc1ee5d28f9155a6.png)

![二叉树前序遍历（迭代法）.gif](https://pic.leetcode-cn.com/1600934720-bMXWmu-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

不难写出如下代码: （**注意代码中空节点不入栈**）

```cpp
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> temp;
        vector<int> result;
        if(root == NULL) return result;
        
        //开始模拟
        temp.push(root);
        while(!temp.empty())
        {
            //定义一个指针，用来存储每次的值
            TreeNode* node = temp.top();    //中
            temp.pop();
            result.push_back(node->val);
            if(node->right) temp.push(node->right);    //右，只有先压右入栈，最后出栈顺序才是中左右
            if(node->left)  temp.push(node->left);      //左
        }
        return result;
    }
```

**用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。**

### 中序遍历

在前序迭代遍历的过程中，其实我们有两个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

分析一下为什么前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

![二叉树中序遍历（迭代法）.gif](https://pic.leetcode-cn.com/1600934697-oafdTT-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

### 后序遍历

#### 正确做法

再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![前序到后序](https://img-blog.csdnimg.cn/20200808200338924.png)

```cpp
class Solution {
public:
    //迭代后序遍历
    //通过迭代前序遍历转换
    //左右中
    //先得到中右左，再反转就是左右中
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> temp;
        vector<int> result;
        if(root == NULL) return result;

        //开始遍历
        temp.push(root);
        while(!temp.empty())
        {
            TreeNode* cur = temp.top(); 
            result.push_back(cur->val); //中
            temp.pop();

            if(cur->left)   temp.push(cur->left);   //左，先把左入栈，出栈才是右
            if(cur->right) temp.push(cur->right);   //右
        }
        reverse(result.begin(),result.end()); //反转 中右左->左右中
        return result;

    }
};
```

#### 尝试用中序遍历的方法—失败

尝试用中序遍历的方法改成后序遍历失败，原因是后序的顺序是左右中，由左到右再到中，然后再push到result中，如下面代码，判断完左右后，返回中，这都没问题，但是下一次循环应该是从当前 中 的上一个节点的右子树开始，这一步无法实现，或者很复杂。

```cpp
class Solution {
public:
    //迭代遍历
    //使用指针
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> temp;
        vector<int> result;
        TreeNode* cur = root;
        if(root == NULL) return result;

        while(cur != NULL || !temp.empty())
        {
            if(cur != NULL){
                temp.push(cur);
                cur = cur->left;    //左
            } else {
                cur = (temp.top())->right; //右
                if(cur == NULL){
                    cur = temp.top();
                    temp.pop();
                    result.push_back(cur->val); //中
                    //出错，此时该中节点的左右都遍历完了，然而下次循环又开始遍历其左节点
                    //下次应该是遍历其上层节点（或上上层，视情况而定）的右子树，而这一步无法实现
                }
            }
        }
        return result;
    }
};
```

如下例：按上面代码，先是1、2入栈，然后遍历2的左子树为NULL，开始遍历2的右子树，然后4、7入栈，然后遍历7的左右子树都为NULL，之后7出栈，到这一步都没问题，但是下一次循环应该是从7的上一层即4的右子树8开始，这一步没法实现，很复杂。

如下：中序是2 7 4 8 1 5 3 6  后序是7 8 4 2 5 6 3 1

![image-20220423202551331](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423202551331.png)

## 二叉树的统一迭代法遍历

之前的迭代法遍历**实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。**

其实**针对三种遍历方式，使用迭代法是可以写出统一风格的代码！**

我们以中序遍历为例，在之前提到说使用栈的话，**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**。

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。

### 前序遍历

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

### 中序遍历

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```

### 后序遍历

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

## 二叉树的层次（层序）遍历

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

力扣102 层次遍历二叉树

![102二叉树的层序遍历](https://pic.leetcode-cn.com/1625474333-VofnSE-008eGmZEly1gnad5itmk8g30iw0cqe83.gif)

两层循环，外层while循环用来存二维数组的“外层”，内层用来存二维数组的内层，即二叉树的每一层的vec数组

```cpp
class Solution {
public:
    //层序遍历，借助queue
    //两层循环
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> temp;
        vector<vector<int>> result;
        vector<int> vec;
        TreeNode* cur;
        int size = 0; //每一层二叉树的节点个数
        int i;
        if(root == NULL) return result;

        temp.push(root); //先将root入队
        while(!temp.empty())//外层
        {
            size = temp.size();
            //vector<int> vec; //要么在每层的循环里都创建新的vec，要么每层用完后都清空vec
            
            for(i = 0; i<size; i++){//内层
                cur = temp.front(); //一直循环size次，将本层的节点依次出队写入本层的vec数组
                temp.pop();
                vec.push_back(cur->val);

                if(cur->left)   temp.push(cur->left);//若cur节点有子节点，则依次入队
                if(cur->right)  temp.push(cur->right);
            }
            result.push_back(vec);
            vec.clear();    //每一层用完要清空vec，否则会造成数据紊乱，或者直接在每层循环里创建新的vec
        }
        return result;
    }
};
```

以上为层次遍历相关的模板，其他与层次相关的题（如下），只需要改动部分代码即可。

层次遍历相关力扣题目：

- 102.二叉树的层序遍历
- 107.二叉树的层次遍历II
- 199.二叉树的右视图
- 637.二叉树的层平均值
- 429.N叉树的层序遍历
- 515.在每个树行中找最大值
- 116.填充每个节点的下一个右侧节点指针
- 117.填充每个节点的下一个右侧节点指针II
- 104.二叉树的最大深度
- 111.二叉树的最小深度



## 翻转二叉树

如果要从整个树来看，翻转还真的挺复杂，整个树以中间分割线进行翻转，如图：

![image-20220425111415959](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220425111415959.png)

想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。

关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ （一些同学这道题都过了，但是不知道自己用的是什么顺序）

遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。

**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了**

那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

### 递归遍历法

我们来看一下递归三部曲：

1. 确定递归函数的参数和返回值

参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode*`。

```cpp
TreeNode* invertTree(TreeNode* root)
```

2. 确定终止条件

当前节点为空的时候，就返回

```cpp
if (root == NULL) return root;
```

3. 确定单层递归的逻辑

因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。

```cpp
swap(root->left, root->right);
invertTree(root->left);
invertTree(root->right);
```

基于这递归三步法，代码基本写完，C++代码如下：

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```

### 迭代遍历法





### 层次遍历法

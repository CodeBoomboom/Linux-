# 栈与队列

栈：先进后出

队列：先进先出

![image-20220228220653706](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220228220653706.png)

栈stack是容器适配器，队列queue也是容器适配器，在STL都是基于deque实现，也可以基于vector、list实现



# 二叉树

## 树

数存储结构：“一对多”

![img](http://c.biancheng.net/uploads/allimg/190427/0944301493-0.png)

**树根结点**、**父节点**（双亲节点）、**子节点**、**兄弟节点**、**叶子节点**（结点没有任何子结点）

**子树**、**空树**（空树中没有结点）

对于一个结点，拥有的子树数（结点有多少分支）称为结点的**度**（Degree）。

结点的**层次**：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。

如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为**有序树**；反之称为**无序树**。

由 m（m >= 0）个互不相交的树组成的集合被称为**森林**。

## 二叉树

满足以下两个条件的树就是**二叉树**：

1. 本身是有序树；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

二叉树**性质**：

1. 二叉树中，第 i 层最多有 2^(i-1) 个结点。
2. 如果二叉树的深度为 K，那么此二叉树最多有 2^K-1 个结点。
3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为**满二叉树**。

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为**完全二叉树**。



## 二叉树的递归遍历

递归三要素

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

遍历：

按照 "从上到下，从左到右" 的顺序遍历整棵二叉树。

![img](http://c.biancheng.net/uploads/allimg/190427/094P344W-2.gif)

整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 3 中的节点 2 为例，如图 4 所示，它被经过了 3 次。

![img](http://c.biancheng.net/uploads/allimg/190427/094P36220-3.gif)

这也就引出了以下 3 种遍历二叉树的算法：

1. 先序遍历：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 中的 ①）；
2. 中序遍历：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 中的 ②）；
3. 后序遍历：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 中的 ③）；

### 先序遍历

1. **确定递归函数的参数和返回值**：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：

```cpp
void traversal(TreeNode* cur, vector<int>& vec)
```

2. **确定终止条件**：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：

```cpp
if (cur == NULL) return;
```

3. **确定单层递归的逻辑**：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：

```cpp
vec.push_back(cur->val);    // 中
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```

完整代码

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

### 中序遍历





### 后序遍历





## 二叉树的迭代遍历



## 二叉树的层次（层序）遍历


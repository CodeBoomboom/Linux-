# 栈与队列

栈：先进后出

队列：先进先出

![image-20220228220653706](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220228220653706.png)

栈stack是容器适配器，队列queue也是容器适配器，在STL都是基于deque实现，也可以基于vector、list实现



# 二叉树

## 二叉树

### 树

数存储结构：“一对多”

![img](http://c.biancheng.net/uploads/allimg/190427/0944301493-0.png)

**树根结点**、**父节点**（双亲节点）、**子节点**、**兄弟节点**、**叶子节点**（结点没有任何子结点）

**子树**、**空树**（空树中没有结点）

对于一个结点，拥有的子树数（结点有多少分支）称为结点的**度**（Degree）。

结点的**层次**：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。

如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为**有序树**；反之称为**无序树**。

由 m（m >= 0）个互不相交的树组成的集合被称为**森林**。

### 二叉树

![二叉树大纲](https://img-blog.csdnimg.cn/20210219190809451.png)

满足以下两个条件的树就是**二叉树**：

1. 本身是有序树；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

二叉树**性质**：

1. 二叉树中，第 i 层最多有 2^(i-1) 个结点。
2. 如果二叉树的深度为 K，那么此二叉树最多有 2^K-1 个结点。
3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

### 二叉树的种类

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为**满二叉树**。

![img](https://img-blog.csdnimg.cn/20200806185805576.png)

如果二叉树中除去最后一层节点之外为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为**完全二叉树**。

![img](https://img-blog.csdnimg.cn/20200920221638903.png)

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

下面这两棵树都是搜索树

![img](https://img-blog.csdnimg.cn/20200806190304693.png)

**平衡二叉搜索树**：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。如图：

![img](https://img-blog.csdnimg.cn/20200806190511967.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

**所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！**

### 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。

链式存储如图：

![img](https://img-blog.csdnimg.cn/2020092019554618.png)

链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？

其实就是用数组来存储二叉树，顺序存储的方式如图：

![img](https://img-blog.csdnimg.cn/20200920200429452.png)

用数组来存储二叉树如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

**所以大家要了解，用数组依然可以表示二叉树**

### 二叉树的遍历方式

关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。

一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。

我这里把二叉树的几种遍历方式列出来，大家就可以一一串起来了。

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

**这两种遍历是图论中最基本的两种遍历方式**，后面在介绍图论的时候 还会介绍到。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。

**这里前中后，其实指的就是中间节点的遍历顺序**，只要大家记住 前中后序指的就是中间节点的位置就可以了。

看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

大家可以对着如下图，看看自己理解的前后中序有没有问题。

![img](https://img-blog.csdnimg.cn/20200806191109896.png)

最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

**之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

**这里其实我们又了解了栈与队列的一个应用场景了。**

具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。

### 二叉树的定义

刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。

C++代码如下：

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。

这里要提醒大家要注意二叉树节点定义的书写方式。

**在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。**

因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！



## 二叉树的递归遍历

递归三要素

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

遍历：

按照 "从上到下，从左到右" 的顺序遍历整棵二叉树。

![img](http://c.biancheng.net/uploads/allimg/190427/094P344W-2.gif)

整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 3 中的节点 2 为例，如图 4 所示，它被经过了 3 次。

![img](http://c.biancheng.net/uploads/allimg/190427/094P36220-3.gif)

这也就引出了以下 3 种遍历二叉树的算法：

1. 先序遍历：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 中的 ①）；
2. 中序遍历：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 中的 ②）；
3. 后序遍历：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 中的 ③）；

### 先/前序遍历

1. **确定递归函数的参数和返回值**：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：

```cpp
void traversal(TreeNode* cur, vector<int>& vec)
```

2. **确定终止条件**：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：

```cpp
if (cur == NULL) return;
```

3. **确定单层递归的逻辑**：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：

```cpp
vec.push_back(cur->val);    // 中
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```

完整代码

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

### 中序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```



### 后序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```



## 二叉树的迭代遍历

### 前序遍历

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

![中序遍历流程图](https://pic.leetcode-cn.com/6233a9685447d0b4d7b513f739151ca065e5697e24070bcafc1ee5d28f9155a6.png)

![二叉树前序遍历（迭代法）.gif](https://pic.leetcode-cn.com/1600934720-bMXWmu-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

不难写出如下代码: （**注意代码中空节点不入栈**）

```cpp
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> temp;
        vector<int> result;
        if(root == NULL) return result;
        
        //开始模拟
        temp.push(root);
        while(!temp.empty())
        {
            //定义一个指针，用来存储每次的值
            TreeNode* node = temp.top();    //中
            temp.pop();
            result.push_back(node->val);
            if(node->right) temp.push(node->right);    //右，只有先压右入栈，最后出栈顺序才是中左右
            if(node->left)  temp.push(node->left);      //左
        }
        return result;
    }
```

**用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。**

### 中序遍历

在前序迭代遍历的过程中，其实我们有两个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

分析一下为什么前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

![二叉树中序遍历（迭代法）.gif](https://pic.leetcode-cn.com/1600934697-oafdTT-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

### 后序遍历

#### 正确做法

再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![前序到后序](https://img-blog.csdnimg.cn/20200808200338924.png)

```cpp
class Solution {
public:
    //迭代后序遍历
    //通过迭代前序遍历转换
    //左右中
    //先得到中右左，再反转就是左右中
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> temp;
        vector<int> result;
        if(root == NULL) return result;

        //开始遍历
        temp.push(root);
        while(!temp.empty())
        {
            TreeNode* cur = temp.top(); 
            result.push_back(cur->val); //中
            temp.pop();

            if(cur->left)   temp.push(cur->left);   //左，先把左入栈，出栈才是右
            if(cur->right) temp.push(cur->right);   //右
        }
        reverse(result.begin(),result.end()); //反转 中右左->左右中
        return result;

    }
};
```

#### 尝试用中序遍历的方法—失败

尝试用中序遍历的方法改成后序遍历失败，原因是后序的顺序是左右中，由左到右再到中，然后再push到result中，如下面代码，判断完左右后，返回中，这都没问题，但是下一次循环应该是从当前 中 的上一个节点的右子树开始，这一步无法实现，或者很复杂。

```cpp
class Solution {
public:
    //迭代遍历
    //使用指针
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> temp;
        vector<int> result;
        TreeNode* cur = root;
        if(root == NULL) return result;

        while(cur != NULL || !temp.empty())
        {
            if(cur != NULL){
                temp.push(cur);
                cur = cur->left;    //左
            } else {
                cur = (temp.top())->right; //右
                if(cur == NULL){
                    cur = temp.top();
                    temp.pop();
                    result.push_back(cur->val); //中
                    //出错，此时该中节点的左右都遍历完了，然而下次循环又开始遍历其左节点
                    //下次应该是遍历其上层节点（或上上层，视情况而定）的右子树，而这一步无法实现
                }
            }
        }
        return result;
    }
};
```

如下例：按上面代码，先是1、2入栈，然后遍历2的左子树为NULL，开始遍历2的右子树，然后4、7入栈，然后遍历7的左右子树都为NULL，之后7出栈，到这一步都没问题，但是下一次循环应该是从7的上一层即4的右子树8开始，这一步没法实现，很复杂。

如下：中序是2 7 4 8 1 5 3 6  后序是7 8 4 2 5 6 3 1

![image-20220423202551331](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220423202551331.png)

## 二叉树的统一迭代法遍历

之前的迭代法遍历**实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。**

其实**针对三种遍历方式，使用迭代法是可以写出统一风格的代码！**

我们以中序遍历为例，在之前提到说使用栈的话，**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**。

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。

### 前序遍历

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

### 中序遍历

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```

### 后序遍历

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

## 二叉树的层次（层序）遍历

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

力扣102 层次遍历二叉树

![102二叉树的层序遍历](https://pic.leetcode-cn.com/1625474333-VofnSE-008eGmZEly1gnad5itmk8g30iw0cqe83.gif)

两层循环，外层while循环用来存二维数组的“外层”，内层用来存二维数组的内层，即二叉树的每一层的vec数组

```cpp
class Solution {
public:
    //层序遍历，借助queue
    //两层循环
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> temp;
        vector<vector<int>> result;
        vector<int> vec;
        TreeNode* cur;
        int size = 0; //每一层二叉树的节点个数
        int i;
        if(root == NULL) return result;

        temp.push(root); //先将root入队
        while(!temp.empty())//外层
        {
            size = temp.size();
            //vector<int> vec; //要么在每层的循环里都创建新的vec，要么每层用完后都清空vec
            
            for(i = 0; i<size; i++){//内层
                cur = temp.front(); //一直循环size次，将本层的节点依次出队写入本层的vec数组
                temp.pop();
                vec.push_back(cur->val);

                if(cur->left)   temp.push(cur->left);//若cur节点有子节点，则依次入队
                if(cur->right)  temp.push(cur->right);
            }
            result.push_back(vec);
            vec.clear();    //每一层用完要清空vec，否则会造成数据紊乱，或者直接在每层循环里创建新的vec
        }
        return result;
    }
};
```

以上为层次遍历相关的模板，其他与层次相关的题（如下），只需要改动部分代码即可。

层次遍历相关力扣题目：

- 102.二叉树的层序遍历
- 107.二叉树的层次遍历II
- 199.二叉树的右视图
- 637.二叉树的层平均值
- 429.N叉树的层序遍历
- 515.在每个树行中找最大值
- 116.填充每个节点的下一个右侧节点指针
- 117.填充每个节点的下一个右侧节点指针II
- 104.二叉树的最大深度
- 111.二叉树的最小深度



## 翻转二叉树

如果要从整个树来看，翻转还真的挺复杂，整个树以中间分割线进行翻转，如图：

![image-20220425111415959](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220425111415959.png)

想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。

关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ （一些同学这道题都过了，但是不知道自己用的是什么顺序）

遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。

**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了**

那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

### 递归遍历法

我们来看一下递归三部曲：

1. 确定递归函数的参数和返回值

参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode*`。

```cpp
TreeNode* invertTree(TreeNode* root)
```

2. 确定终止条件

当前节点为空的时候，就返回

```cpp
if (root == NULL) return root;
```

3. 确定单层递归的逻辑

因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。

```cpp
swap(root->left, root->right);
invertTree(root->left);
invertTree(root->right);
```

基于这递归三步法，代码基本写完，C++代码如下：

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```

### 迭代遍历法

重点是翻转卷每个节点的左右子节点

#### 一般迭代

```cpp
class Solution {
public:
    //迭代法(前序遍历)
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> temp;
        if(root != NULL) temp.push(root);
        while(!temp.empty()){
            TreeNode* cur = temp.top(); //中
            temp.pop();
            //result.push_back(cur->val);
            swap(cur->left,cur->right); //翻转
            if(cur->right) temp.push(cur->right);   // 右，因为是stack，所以先右后左
            if(cur->left) temp.push(cur->left);     // 左            

        }
        return root;

    }
};
```

#### 统一迭代

```cpp
class Solution {
public:
    //统一迭代法(前序遍历)
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> temp;
        if(root != NULL) temp.push(root);
        while(!temp.empty()){
            TreeNode* cur = temp.top();
            if(cur != NULL){ //下一个出栈的不是“中”
                temp.pop();//先出栈，再按右左中顺序入栈，防止重复入栈
                if (cur->right) temp.push(cur->right);  // 右
                if (cur->left) temp.push(cur->left);    // 左
                temp.push(cur);                          // 中
                temp.push(NULL);
            }else{//说明下一个出栈的是“中”,出栈的时候把其左右子节点翻转一下就好
                temp.pop();//null出栈
                cur = temp.top();
                temp.pop();
                swap(cur->left, cur->right);
            }
        }
        return root;
    }
};
```



### 层次遍历法

重点是翻转卷每个节点的左右子节点

```cpp
class Solution {
public:
    //层次遍历法
    //实质上就是翻转每个节点的左右子节点
    TreeNode* invertTree(TreeNode* root) {
        queue<TreeNode*> temp;
        if(root != NULL) temp.push(root);

        while(!temp.empty())
        {
            int size = temp.size();
            TreeNode* cur;
            for(int i = 0; i<size; i++){
                cur = temp.front();
                temp.pop();
                swap(cur->left,cur->right); //翻转左右子节点
                if(cur->left)   temp.push(cur->left);
                if(cur->right)  temp.push(cur->right);
            }
        }
        return root; 
    }
};
```













# 查找表

## 红黑树

红黑树（R-B TREE，全称：Red-Black Tree），本身是一棵二叉查找树，在其基础上附加了两个要求：

1. 树中的每个结点增加了一个用于存储颜色的标志域；
2. 树中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。
